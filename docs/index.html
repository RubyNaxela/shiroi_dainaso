<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>Shiroi Dainaso</title>
    <link href="prism.css" rel="stylesheet"/>
    <link href="style.css" rel="stylesheet"/>
</head>
<body>

<div id="container">

    <div id="header">
        <img src="dainaso_idle.png" alt="">
        <div id="title"><span class="latin">Shiroi Dainaso</span><br><span class="japanese">白いダイナソー</span></div>
        <img src="cactus_small.png" alt="">
    </div>

    <div id="container-body" class="line-numbers">

        <div id="table-of-contents">
            <h3 style="margin-bottom: 0.5rem">Spis treści</h3>
            <ol>
                <li>&#x2001;Cel projektu</li>
                <li>&#x2001;Specyfikacja wymagań projektowych
                    <ol>
                        <li>&#x2001;Wymagania funkcjonalne</li>
                        <li>&#x2001;Wymagania pozafunkcjonalne</li>
                    </ol>
                </li>
                <li>&#x2001;Szczegóły techniczne / ciekawostki
                    <ol>
                        <li>&#x2001;Użyta technologia</li>
                        <li>&#x2001;Paradygmat obiektowy
                            <ol>
                                <li>&#x2001;Polimorfizm, abstrakcja</li>
                                <li>&#x2001;Dziedziczenie</li>
                            </ol>
                        </li>
                        <li>&#x2001;Zarządzanie assetami</li>
                    </ol>
                </li>
            </ol>

        </div>

        <h1 class="section-title">1&#x2001;Cel projektu</h1>

        <p class="align-justify">Celem projektu Shiroi Dainaso jest stworzenie repliki Chrome Dino — gry zręcznościowej
            wbudowanej w&nbsp;Google Chrome, polegającej na przeskakiwaniu postacią dinozaura przez kaktusy i unikaniu
            przelatujących pterodaktyli. W założeniu, nie ma być wierną kopią, lecz grą o zbliżonym działaniu
            i&nbsp;oprawie audiowizualnej — inspirowanej grami komputerowymi z lat '70. Projekt dopuszcza także
            wykroczenie w przyszłości poza funkcjonalności pierwowzoru.</p>

        <h1 class="section-title">2&#x2001;Specyfikacja wymagań projektowych</h1>

        <h2 class="section-title">2.1&#x2001;Wymagania funkcjonalne</h2>

        <table>
            <thead>
            <tr>
                <td class="align-right">Lp.</td>
                <td>Element gry</td>
                <td class="align-center">Priorytet</td>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td class="align-right">1</td>
                <td>Postać dinozaura samoczynnie poruszająca się do przodu</td>
                <td class="align-center">wysoki</td>
            </tr>
            <tr>
                <td class="align-right">2</td>
                <td>Przewijanie sceny z efektem paralaksy</td>
                <td class="align-center">średni</td>
            </tr>
            <tr>
                <td class="align-right">3</td>
                <td>Możliwość sterowania postacią dinozaura: wykonanie skoku i uniku</td>
                <td class="align-center">wysoki</td>
            </tr>
            <tr>
                <td class="align-right">4</td>
                <td>Pojawianie się na scenie przeszkód: kaktusów i pterodaktyli w losowych odstępach</td>
                <td class="align-center">wysoki</td>
            </tr>
            <tr>
                <td class="align-right">5</td>
                <td>Warianty przeszkód: dla kaktusów &ndash; małe (w grupach 1&ndash;3) i duże (w grupach 1&ndash;2)
                    i&nbsp;pterodaktyli (zmienna wysokość lotu)
                </td>
                <td class="align-center">średni</td>
            </tr>
            <tr>
                <td class="align-right">6</td>
                <td>Możliwość ponownego rozpoczęcia gry po przegranej</td>
                <td class="align-center">średni</td>
            </tr>
            <tr>
                <td class="align-right">7</td>
                <td>Stopniowe zwiększanie prędkości przewijania sceny</td>
                <td class="align-center">wysoki</td>
            </tr>
            </tbody>
        </table>
        <p class="caption top-margin"><b>Tabela 1.</b>&#x2002;Wymagania funkcjonalne gry.</p>

        <h2 class="section-title">2.2&#x2001;Wymagania pozafunkcjonalne</h2>

        <table>
            <thead>
            <tr>
                <td class="align-right">Lp.</td>
                <td>Element gry</td>
                <td class="align-center">Priorytet</td>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td class="align-right">1</td>
                <td>Kod gry napisany w całości w języku C</td>
                <td class="align-center">średni</td>
            </tr>
            <tr>
                <td class="align-right">2</td>
                <td>Zablokowanie możliwości zmiany rozmiaru okna</td>
                <td class="align-center">wysoki</td>
            </tr>
            <tr>
                <td class="align-right">3</td>
                <td>Pojawianie się na scenie elementów dekoracyjnych</td>
                <td class="align-center">wysoki</td>
            </tr>
            <tr>
                <td class="align-right">4</td>
                <td>Proste animacje postaci zwierzęcych</td>
                <td class="align-center">wysoki</td>
            </tr>
            <tr>
                <td class="align-right">5</td>
                <td>Licznik punktów w rogu okna</td>
                <td class="align-center">wysoki</td>
            </tr>
            <tr>
                <td class="align-right">6</td>
                <td>Dźwięk towarzyszący zdarzeniom: skok, uzyskanie wielokrotności 100 punktów, koniec gry</td>
                <td class="align-center">wysoki</td>
            </tr>
            <tr>
                <td class="align-right">7</td>
                <td>Zapisanie najlepszego wyniku, wyświetlanie go przy liczniku punktów</td>
                <td class="align-center">średni</td>
            </tr>
            <tr>
                <td class="align-right">8</td>
                <td>Ekran końca gry</td>
                <td class="align-center">niski</td>
            </tr>
            </tbody>
        </table>
        <p class="caption top-margin"><b>Tabela 2.</b>&#x2002;Wymagania pozafunkcjonalne gry.</p>

        <h1 class="section-title">3&#x2001;Szczegóły techniczne / ciekawostki</h1>

        <h2 class="section-title">3.1&#x2001;Użyta technologia</h2>

        <p class="align-justify">Gra została stworzona przy pomocy biblioteki graficznej
            <a href="https://www.sfml-dev.org/download/csfml/">SFML</a> autorstwa Laurenta Gomili. Użycie portu na język
            C umożliwiło napisanie całości kodu gry w tym języku.</p>

        <h2 class="section-title">3.2&#x2001;Paradygmat obiektowy</h2>

        <h3 class="section-title">3.2.1&#x2001;Polimorfizm, abstrakcja</h3>

        <p class="align-justify">W celu ułatwienia pracy i utrzymania przejrzystego kodu, projekt jest stworzony z
            zachowaniem zasad programowania obiektowego. Z racji natury języka C, który nie obsługuje programowania
            obiektowego, mechanizmy takie jak dziedziczenie i abstrakcja musiały zostać zaimplementowane ręcznie.
            Przykład:</p>

        <div class="vertical-margin">
            <pre>
<code class="language-cpp">void dsScene_iteration(dsScene* _this, float deltaTime) {
    g.speed += deltaTime * 0.005f;
    for (__dsListNode* node = _this->__head; node != null; node = node->next) {
        dsGameObject* object = node->object;
        object->behavior(object, deltaTime);
        if ((INSTANCE_OF(object, dsCactus) or INSTANCE_OF(object, dsPterodactyl))
            and dsDinosaur_touching(_this->__player, object))
            dsScene_gameOver(_this);
        if (INSTANCE_OF(object, dsScrollingObject)
            and ((dsScrollingObject*) object)->markedToRemove)
            dsScene_remove(_this, object);
    }
}</code>
            </pre>
            <p class="caption"><b>Listing 1.</b>&#x2002;Metoda wykonywana w każdej klatce gry.</p>
        </div>

        <p class="align-justify">Powyższa funkcja jest de facto metodą instancyjną struktury
            <code class="language-">dsScene</code>. Sygnalizuje to obecność argumentu
            <code class="language-">_this</code>, który pełni funkcję obiektu, na którym wywoływana jest metoda.
            W językach obiektowych, argument ten generowany jest niejawnie podczas kompilacji. Pętla
            <code class="language-">for</code> przechodzi przez wszystkie obiekty struktury
            <code class="language-">dsGameObject</code>, która jest bazą wszystkich struktur
            reprezentujących widoczne elementy gry (dinozaur, kaktus, chmura, licznik punktów itd.).</p>
        <p class="align-justify top-margin">W linijce 5 wywoływana jest metoda abstakcyjna
            <code class="language-">behavior</code>. Każdy typ obiektu ma inną wersję tej metody (np. dinozaur zmienia
            wygląd w ramach animacji oraz reaguje na sterowanie, a chmura przesuwa się w lewo po scenie). Niżej
            uruchamiane są procedury sceny dla konkretnych grup typów obiektów.</p>

        <h3 class="section-title">3.2.2&#x2001;Dziedziczenie</h3>

        <p class="align-justify"></p>

        <p class="align-justify">Język C nie obsługuje dziedziczenia struktur. Nie przeszkadza to jednak w samodzielnym
            stworzeniu takiego mechanizmu. Poniższy kod przedstawia strukturę
            <code class="language-">dsGameObject</code>, która pełni funkcję klasy abstrakcyjnej (słowo
            <code class="language-">abstract</code> jest jedynie adnotacją; semantycznie nie pełni żadnej funkcji) oraz
            strukturę <code class="language-">dsDinosaur</code>, która "dziedziczy" z
            <code class="language-">dsGameObject</code> wszystkie pola i metody.</p>

        <pre>
<code class="language-c">typedef abstract struct dsGameObject {
    dsGameObjectType type;
    sfRectangleShape* sprite;
    abstract void (* behavior)(dsGameObject*, float);
    abstract void (* draw)(const dsGameObject*, sfRenderWindow*);
} dsGameObject;

#define dsGameObject_BASE dsGameObjectType type; sfRectangleShape* sprite;\
                          void (* behavior) (dsGameObject*, float);\
                          void (* draw)(const dsGameObject*, sfRenderWindow*);

typedef struct dsDinosaur {
    extends(dsGameObject)

    const sfTexture* hitTexture, * idleTexture, * duck1Texture,
                   * duck2Texture, * step1Texture, * step2Texture;
    sfSound* jumpSound;
    float velocityY;
    bool jumping, ducking, __ignoreJump, __firstJumpIgnored;
} dsDinosaur;</code>
            </pre>
        <p class="caption"><b>Listing 2.</b>&#x2002;Bazowa "klasa" abstrakcyjna i "klasa" z niej dziedzicząca.</p>

        <h2 class="section-title">3.3&#x2001;Zarządzanie assetami</h2>

        <p class="align-justify">Obiekty w grze korzystają z globalnie dostępnych assetów. Poza ułatwieniem pracy,
            dzięki takiemu rozwiązaniu, każda tekstura czy dźwięk przechowywane są w pamięci tylko raz, przez cały czas
            uruchomienia gry, bez potrzeby tworzenia nowego obiektu assetu dla każdego kaktusa czy pterodaktyla:</p>

        <div class="vertical-margin">
            <pre>
<code class="language-c">dsAssetsBundle_register(g.assets, "ds:font.pixelboy",
                        ds_createFont("assets/pixel_boy.ttf"));
dsAssetsBundle_register(g.assets, "ds:sound.dainaso.hit",
                        ds_createSound("assets/game_over_ds:sound.ogg"));
dsAssetsBundle_register(g.assets, "ds:sound.dainaso.jump",
                        ds_createSound("assets/jump_ds:sound.ogg"));
dsAssetsBundle_register(g.assets, "ds:texture.cactus.large",
                        ds_createTexture("assets/cactus_large.png"));
dsAssetsBundle_register(g.assets, "ds:texture.cactus.small",
                        ds_createTexture("assets/cactus_small.png"));
dsAssetsBundle_register(g.assets, "ds:texture.cloud",
                        ds_createTexture("assets/cloud.png"));
// ...</code>
            </pre>
            <p class="caption"><b>Listing 3.</b>&#x2002;Rejestracja niektórych assetów.</p>
        </div>

        <div class="vertical-margin">
            <pre>
<code class="language-c">void dsText_super(dsText* _this) {
    // ...
    dsText_setHorizontalAlignment(_this, dsStart);
    dsText_setVerticalAlignment(_this, dsStart);
    sfText_setFillColor(_this->__text, g.config.textColor);
    sfText_setFont(_this->__text, dsAssetsBundle_get(g.assets, "ds:font.pixelboy"));
}</code>
            </pre>
            <p class="caption"><b>Listing 4.</b>&#x2002;Wykorzystanie czcionki z biblioteki assetów (linijka 6) przy
                tworzeniu obiektu tekstu.</p>
        </div>

    </div>

</div>

<script src="prism.js"></script>
</body>
</html>